// Generated by CoffeeScript 1.8.0
(function() {
  var CSSRize, Vector;

  Vector = (function() {
    function Vector(x, y, z) {
      if ((x.x != null) && (y.x != null)) {
        this.x = y.x - x.x;
        this.y = y.y - x.y;
        this.z = y.z - x.z;
      } else {
        this.x = x;
        this.y = y;
        this.z = z;
      }
    }

    Vector.prototype.add = function(vector) {
      return new Vector(this.x + vector.x, this.y + vector.y, this.z + vector.z);
    };

    Vector.prototype.sub = function(vector) {
      return new Vector(this.x + vector.x, this.y - vector.y, this.z - vector.z);
    };

    Vector.prototype.dot = function(vector) {
      return this.x * vector.x + this.y * vector.y + this.z * vector.z;
    };

    Vector.prototype.cross = function(vector) {
      return new Vector(this.y * vector.z - this.z * vector.y, this.z * vector.x - this.x * vector.z, this.x * vector.y - this.y * vector.x);
    };

    Vector.prototype.norm = function() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    };

    return Vector;

  })();

  CSSRize = (function() {
    var atan2, cos, createScene, createTextureBlob, getFile, norm, parseObjFile, setScene, sin, tan, _exportTestTexture, _objData;

    function CSSRize() {}

    _objData = null;

    CSSRize.prototype.run = function(args) {
      if (args.scenePlace == null) {
        throw "set scenePlace";
      }
      if (args.objFile == null) {
        throw "set objFile";
      }
      if (args.texFile == null) {
        args.texFile = null;
      }
      if (args.texResolution == null) {
        args.texResolution = null;
      }
      console.log("parsing...");
      return parseObjFile(args.objFile).then(function(objData) {
        var d, texImg;
        d = new $.Deferred;
        if (args.texFile != null) {
          if (args.texResolution != null) {
            texImg = new Image(args.texResolution, args.texResolution);
          } else {
            texImg = new Image();
          }
          texImg.onload = function() {
            var canvas, ctx;
            if (args.texResolution != null) {
              canvas = $('<canvas>').get(0);
              ctx = canvas.getContext("2d");
              canvas.width = args.texResolution;
              canvas.height = args.texResolution;
              ctx.drawImage(texImg, 0, 0, args.texResolution, args.texResolution);
              return d.resolve(objData, canvas);
            } else {
              return d.resolve(objData, texImg);
            }
          };
          texImg.onerror = function() {
            return d.resolve(objData);
          };
          texImg.src = args.texFile;
        } else {
          d.resolve(objData);
        }
        return d.promise();
      }).then(function(objData, texImg) {
        if (texImg == null) {
          texImg = null;
        }
        console.log("creating...");
        return createScene($(args.scenePlace), objData, texImg);
      }).then(function($scene) {
        return setScene($scene);
      }).then(function() {
        return console.log("done!");
      });
    };

    createScene = function($place, objData, texImg, scale) {
      var $face, $obj, blob, color, d, fNumber, face, height, objF, objT, objV, phi, psi, rad, theta, v, vecPQ, vecPQ1, vecPR, vecPR1, vecPR2, width;
      if (texImg == null) {
        texImg = null;
      }
      if (scale == null) {
        scale = 10;
      }
      d = new $.Deferred;
      objV = objData.vertex;
      objT = objData.texture;
      objF = objData.face;
      $obj = $('<div class="rize_obj"></div>');
      $place.addClass("rize_scene").append($obj);
      for (fNumber in objF) {
        face = objF[fNumber];
        if (face.length === 3) {
          $face = $('<div class="rize_face"></div>');
          v = [objV[face[0].vNumber], objV[face[2].vNumber], objV[face[1].vNumber]];
          vecPQ = new Vector(v[1], v[0]);
          vecPR = new Vector(v[2], v[0]);
          theta = -atan2(vecPQ.y, vecPQ.x);
          vecPQ1 = new Vector(vecPQ.x * cos(theta) + vecPQ.y * -sin(theta), vecPQ.x * sin(theta) + vecPQ.y * cos(theta), vecPQ.z);
          vecPR1 = new Vector(vecPR.x * cos(theta) + vecPR.y * -sin(theta), vecPR.x * sin(theta) + vecPR.y * cos(theta), vecPR.z);
          phi = Math.PI / 2 - atan2(vecPQ1.x, vecPQ1.z);
          vecPR2 = new Vector(vecPR1.x * cos(phi) + vecPR1.z * sin(phi), vecPR1.y, vecPR1.x * -sin(phi) + vecPR1.z * cos(phi));
          psi = -atan2(vecPR2.z, vecPR2.y);
          width = vecPQ.norm();
          height = vecPQ.cross(vecPR).norm() / width;
          rad = Math.acos(vecPQ.dot(vecPR) / (vecPQ.norm() * vecPR.norm()));
          $face.css({
            transform: ("translate3D(" + (v[0].x * scale) + "em, ") + ("" + (v[0].y * scale) + "em, ") + ("" + (v[0].z * scale) + "em) ") + ("matrix3D(                                   " + (-cos(theta) * cos(phi)) + ",                                     " + (sin(theta) * cos(phi)) + ",            " + (-sin(phi)) + ", 0, ") + ("" + (-sin(theta) * cos(psi) - cos(theta) * sin(phi) * sin(psi)) + ", " + (-cos(theta) * cos(psi) + sin(theta) * sin(phi) * sin(psi)) + ",  " + (cos(phi) * sin(psi)) + ", 0, ") + ("" + (-sin(theta) * sin(psi) + cos(theta) * sin(phi) * cos(psi)) + ", " + (-cos(theta) * sin(psi) - sin(theta) * sin(phi) * cos(psi)) + ", " + (-cos(phi) * cos(psi)) + ", 0, ") + "                                                           0,                                                            0,                       0, 1) " + ("skewX(" + (Math.PI / 2 - rad) + "rad)") + ""
          });
          if ((texImg != null) && ((blob = createTextureBlob(texImg, objT[face[0].vtNumber], objT[face[1].vtNumber], objT[face[2].vtNumber])) != null)) {
            $face.css({
              width: "" + (width * scale) + "em",
              height: "" + (height * scale) + "em",
              "background-image": "url(" + blob + ")"
            });
          } else {
            color = Math.round(220 + Math.abs(theta / Math.PI) * (256 - 220));
            $face.css({
              "border-style": "solid",
              "border-width": "" + (height * scale) + "em " + (width * scale) + "em 0 0",
              "border-color": "rgba(" + color + ", " + color + ", " + color + ", 0.5) transparent transparent transparent"
            });
          }
          $obj.append($face);
        }
      }
      d.resolve($place);
      return d.promise();
    };

    createTextureBlob = function(texture, vtP, vtQ, vtR) {
      var areaHeight, areaWidth, areaX, areaY, canvas, context, phi, texHeight, texWidth, theta, tx, ty, vtS;
      if ((vtP == null) || (vtQ == null) || (vtR == null) || (vtP.x == null) || (vtQ.x == null) || (vtR.x == null)) {
        return null;
      }
      canvas = $('<canvas>').get(0);
      context = canvas.getContext("2d");
      texWidth = texture.width;
      texHeight = texture.height;
      tx = function(vt) {
        return vt.x * texWidth;
      };
      ty = function(vt) {
        return (1 - vt.y) * texHeight;
      };
      vtS = {
        x: vtP.x + (vtQ.x - vtP.x) + (vtR.x - vtP.x),
        y: vtP.y + (vtQ.y - vtP.y) + (vtR.y - vtP.y)
      };
      areaX = Math.min(tx(vtP), tx(vtQ), tx(vtR), tx(vtS));
      areaY = Math.min(ty(vtP), ty(vtQ), ty(vtR), ty(vtS));
      areaWidth = Math.max(tx(vtP), tx(vtQ), tx(vtR), tx(vtS)) - areaX;
      areaHeight = Math.max(ty(vtP), ty(vtQ), ty(vtR), ty(vtS)) - areaY;
      theta = -atan2(ty(vtR) - ty(vtP), tx(vtR) - tx(vtP));
      phi = atan2(ty(vtQ) - ty(vtP), tx(vtQ) - tx(vtP)) + theta + Math.PI / 2;
      canvas.width = norm([tx(vtR) - tx(vtP), ty(vtR) - ty(vtP)]);
      canvas.height = norm([tx(vtQ) - tx(vtP), ty(vtQ) - ty(vtP)]) * cos(Math.PI + phi);
      context.beginPath();
      context.moveTo(0, 0);
      context.lineTo(canvas.width * 1.05, 0);
      context.lineTo(0, canvas.height * 1.05);
      context.closePath();
      context.clip();
      context.transform(1, 0, tan(phi), 1, 0, 0);
      context.transform(cos(theta), sin(theta), -sin(theta), cos(theta), 0, 0);
      context.drawImage(texture, areaX, areaY, areaWidth, areaHeight, areaX - tx(vtP), areaY - ty(vtP), areaWidth, areaHeight);
      return canvas.toDataURL();
    };

    setScene = function($place) {
      var d, x, y;
      d = new $.Deferred;
      x = 0;
      y = 0;
      $place.on("touchmove", (function(_this) {
        return function(events) {
          var _ref;
          events.preventDefault();
          return (_ref = _this.$rotatee) != null ? _ref.css("transform", ("rotateY(" + (event.changedTouches[0].pageX - _this.x) + "deg)") + ("rotateX(" + (_this.y - event.changedTouches[0].pageY) + "deg)")) : void 0;
        };
      })(this)).on("mousemove", (function(_this) {
        return function(events) {
          var _ref;
          return (_ref = _this.$rotatee) != null ? _ref.css("transform", ("rotateY(" + (events.clientX - _this.x) + "deg)") + ("rotateX(" + (_this.y - events.clientY) + "deg)")) : void 0;
        };
      })(this)).on("touchend mouseup", (function(_this) {
        return function(events) {
          return _this.$rotatee = null;
        };
      })(this)).on("touchstart", (function(_this) {
        return function(events) {
          if (_this.$rotatee == null) {
            _this.$rotatee = $place.find(".rize_obj");
            _this.x = event.changedTouches[0].pageX;
            return _this.y = event.changedTouches[0].pageY;
          }
        };
      })(this)).on("mousedown", (function(_this) {
        return function(events) {
          if (_this.$rotatee == null) {
            _this.$rotatee = $place.find(".rize_obj");
            _this.x = events.clientX;
            return _this.y = events.clientY;
          }
        };
      })(this));
      d.resolve($place);
      return d.promise();
    };

    parseObjFile = function(objFile) {
      var d, objData;
      d = new $.Deferred;
      objData = {};
      objData.vertex = {};
      objData.texture = {};
      objData.face = {};
      getFile(objFile).then(function(data) {
        var buf, fNumber, face, faces, info, tok, tokens, vNumber, vtNumber, _i, _j, _len, _len1, _ref;
        vNumber = 1;
        vtNumber = 1;
        fNumber = 1;
        _ref = data.split("\n");
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          buf = _ref[_i];
          if (buf.indexOf("#") === 0) {
            continue;
          }
          tokens = buf.split(" ");
          if (tokens.length < 1) {
            continue;
          }
          switch (tokens[0].toLowerCase()) {
            case "usemtl":
              continue;
            case "v":
              objData.vertex[vNumber] = {
                x: +tokens[1],
                y: -tokens[2],
                z: +tokens[3]
              };
              vNumber += 1;
              break;
            case "vt":
              objData.texture[vtNumber] = {
                x: +tokens[1],
                y: +tokens[2]
              };
              vtNumber += 1;
              break;
            case "f":
              faces = [];
              tokens.shift();
              for (_j = 0, _len1 = tokens.length; _j < _len1; _j++) {
                tok = tokens[_j];
                info = tok.split("/");
                face = {};
                face.vNumber = +info[0];
                if ((info[1] != null) && info[1] !== "") {
                  face.vtNumber = +info[1];
                }
                if ((info[2] != null) && info[2] !== "") {
                  face.vnNumber = +info[2];
                }
                faces.push(face);
              }
              objData.face[fNumber] = faces;
              fNumber += 1;
              break;
            default:
              continue;
          }
        }
        _objData = objData;
        return d.resolve(objData);
      });
      return d.promise();
    };

    getFile = function(file) {
      var d;
      d = new $.Deferred;
      $.get(file).done(function(data, textStatus) {
        return d.resolve(data);
      }).fail(function(jqxhr, settings, exception) {
        console.log("file not found! : " + file);
        return d.reject(jqxhr);
      });
      return d.promise();
    };

    sin = function(x) {
      return Math.sin(x);
    };

    cos = function(x) {
      return Math.cos(x);
    };

    tan = function(x) {
      return Math.tan(x);
    };

    atan2 = function(y, x) {
      return Math.atan2(y, x);
    };

    norm = function(arr, sum) {
      var s;
      if (sum == null) {
        sum = 0;
      }
      if (arr.length === 0) {
        return Math.sqrt(sum);
      } else {
        s = arr.shift();
        return norm(arr, sum + s * s);
      }
    };

    _exportTestTexture = function($scene_place, objData, texImg) {
      return parseObjFile(objFile).then(function(objData) {
        texImg = new Image();
        texImg.onload = function() {
          var $canvas, canvas, ctx, vt, vtNumber, _ref;
          $canvas = $('<canvas>');
          canvas = $canvas.get(0);
          ctx = canvas.getContext("2d");
          canvas.width = texImg.width;
          canvas.height = texImg.height;
          ctx.drawImage(texImg, 0, 0);
          _ref = objData.texture;
          for (vtNumber in _ref) {
            vt = _ref[vtNumber];
            ctx.fillRect(vt.x * canvas.width - 3, (1 - vt.y) * canvas.height - 3, 6, 6);
          }
          return $scene_place.append($canvas);
        };
        return texImg.src = texFile;
      });
    };

    return CSSRize;

  })();

  $((function(_this) {
    return function() {
      return new CSSRize().run({
        scenePlace: $("#scene").get(0),
        objFile: "data/sphere.obj",
        texFile: "data/sphere.png",
        texResolution: 2048
      });
    };
  })(this));

}).call(this);

//# sourceMappingURL=main.js.map
